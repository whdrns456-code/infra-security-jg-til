# 📅 TIL: 2026-02-06

## 📝 1. 오늘의 학습 주제 및 핵심 내용
- **주요 주제:** 주제를 입력하세요
- **핵심 개념 1:** 
    파이프(|)와 데이터 가공
리다이렉션 & 파이프: 프로그램의 출력을 모니터가 아니라 파일로 보내거나(>), 다른 프로세스의 입력으로 보낼 때 사용함.

파이프(|): 왼쪽 명령어의 결과값을 오른쪽 명령어의 입력으로 전달. 여러 개 연결 가능.

ls -l | wc -l: 파일 개수 세기

cat /etc/passwd | sort -r | more: 역순 정렬해서 페이지 단위로 보기

주요 명령어 조합:

grep: 특정 문자열 검색 (예: ps -ef | grep 'bash')

sort: 데이터 정렬 (-r은 내림차순)

head / tail: 앞부분 또는 뒷부분만 보기

2. 히스토리 및 편의 기능
history: 지금까지 입력한 명령어 목록 확인.

history 5: 최근 5개만 보기

!!: 바로 직전 명령어 재실행

!번호: 히스토리 목록의 특정 번호 명령어 실행

Tab 자동완성: 명령어와 파일명을 한글자씩 치지 말고 Tab 키로 자동완성하는 습관이 중요함.

3. 환경 설정 파일 (초기화 파일)
전역 설정 (/etc/): root만 수정 가능, 모든 계정에 적용.

/etc/profile: 모든 계정 로그인 시 적용.

/etc/bashrc: 모든 계정 bash 쉘 실행 시 적용.

개별 설정 (~/): 각 사용자의 홈 디렉터리에 존재.

~/.bashrc: 비로그인 쉘(새 터미널) 실행 시마다 적용. 실무에서 가장 많이 건드리는 파일.

~/.bash_profile: 로그인할 때 딱 한 번 실행. 내부에서 .bashrc를 불러오는 코드가 포함되어 있음.

🔥 핵심 질문 해결 1: 왜 .bash_profile 대신 .bashrc를 주로 쓸까?

.bash_profile은 '로그인'용이라 딱 한 번만 실행됨.

반면 .bashrc는 '쉘 실행'용이라 새 창을 열 때마다 적용됨.

.bash_profile이 실행될 때 .bashrc를 자동으로 불러오도록(Sourcing) 설정되어 있어서, 관리 편의상 .bashrc 한 곳에만 설정을 몰아넣는 게 국룰임.

4. 변수와 상속
변수 선언: 변수명=값 (대입 시 공백 절대 금지!)

쉘 변수 vs 환경 변수:

쉘 변수: 현재 쉘 안에서만 유효함.

환경 변수: 자식 프로세스까지 상속됨 (export 사용).

상속 개념: fork()를 통해 자식이 부모의 환경을 복사해오지만, 메모리 공간은 분리됨.

중요 환경 변수:

$PATH: 명령어를 찾는 경로 목록 (매우 중요!)

$HOME: 사용자의 홈 디렉터리 경로

$SHELL: 현재 사용 중인 쉘 종류

명령어:

env: 환경 변수만 확인 / set: 모든 변수 확인

export 변수명: 쉘 변수를 환경 변수로 승격

unset 변수명: 변수 삭제

5. 실습 트러블슈팅 (중요!)
🔥 핵심 질문 해결 2: echo $test1 결과가 왜 안 보였을까?

오타 체크: export tset1=1로 저장하고 echo $test1로 부르면 안 나옴. 철자(e, s 순서) 엄격함.

반영(Sourcing): .bashrc 파일에 내용을 추가했다고 바로 적용되는 게 아님. 쉘은 실행될 때 파일을 읽기 때문에, 수정 후에는 반드시 source ~/.bashrc 명령어로 즉시 반영해줘야 함.


- **핵심 개념 2:오후 수업 프로세스 관리와 시그널 제어 작업 관리** 

📑 오늘 학습한 리눅스 핵심 (2026-02-06)
1. 프로세스(Process)와 관리
프로세스는 실행 중인 프로그램을 의미하며, 부모-자식 관계의 계층 구조를 가집니다.

주요 프로세스 유형

데몬(Daemon): 시스템 백그라운드에서 상주하며 서비스를 제공하는 프로세스 (이름 뒤에 d가 붙음. 예: sshd, httpd).

고아(Orphan): 부모 프로세스가 먼저 종료되어 systemd(PID 1)가 입양한 프로세스.

좀비(Zombie): 실행은 끝났으나 종료 정보가 부모에게 전달되지 않아 프로세스 테이블에 남은 상태 (STAT이 Z).

핵심 명령어

ps -ef: 모든 프로세스의 부모-자식 관계(PPID) 확인 가능.

ps aux: CPU, 메모리 사용량 등 리소스 중심 확인.

pstree -p: 프로세스 계층 구조를 트리 형태로 시각화.

pgrep: 특정 이름의 프로세스 PID만 빠르게 검색.

2. 시그널(Signal) 제어
프로세스에 명령을 내리는 신호입니다.

kill -15 (SIGTERM): 정상 종료 요청 (권장).

kill -9 (SIGKILL): 강제 종료 (프로세스가 응답 없을 때 사용).

kill -1 (SIGHUP): 설정 파일 재설정(Restart 효과).

3. 작업 관리 (Job Control)
- Foreground: 터미널을 점유하여 실행 중인 작업.
- Background (&): 터미널 입력이 가능한 상태로 뒤에서 실행.
예시 코드 -  [root@localhost ~]# sleep 100 &

- 주요 단축키: Ctrl + Z(일시정지 및 백그라운드로 전환), fg %번호(다시 앞으로 가져오기).

4. 아카이브와 압축 (Tar & Compress)
    - 아카이브(Archive): 여러 파일을 하나로 묶는 것 (용량은 줄어들지 않음).
    - 압축(Compression): 알고리즘을 사용해 용량을 줄이는 것.

- 조합 사용:
- tar zcvf: gzip 사용 (가장 빠름, .tar.gz)
- tar jcvf: bzip2 사용 (압축률 높음, .tar.bz2)
- zip / unzip: 윈도우와 호환성 좋음.

- **예시**  
    - # 아카이브 생성 (a, b, c 파일을 text.tar로 묶기)
    - [root@localhost ~]# tar cvf text.tar a b c

    - # 아카이브 내용 확인 (풀기 전에 확인)
    - [root@localhost ~]# tar tvf text.tar
    - -rw-r--r-- root/root  0 2026-02-06 15:11 a
    - -rw-r--r-- root/root  0 2026-02-06 15:11 b

- # 아카이브 해제 (원본 파일 추출)
    - [root@localhost ~]# tar xvf text.tar

- 형식,명령어 옵션,특징
    - .tar.gz,tar zcvf,gzip 사용. 압축 속도가 빠르고 가장 대중적임.
    - .tar.bz2,tar jcvf,bzip2 사용. 압축 속도는 느리지만 압축률이 뛰어남.


- # 1, 2, 3 파일을 gzip으로 압축하여 묶기
    - [root@localhost ~]# tar zcvf number.tar.gz 1 2 3

- # bzip2 방식으로 압축하여 묶기
    - [root@localhost ~]# tar jcvf n.tar.bz2 1 2 3    


- # 단일 파일 압축 (압축 후 원본 'a'는 사라지고 'a.gz'가 생성됨)
    - [root@localhost ~]# gzip a

- # 윈도우 호환 zip 압축
    - [root@localhost ~]# yum install zip unzip -y  # 패키지 설치 필요
    - [root@localhost ~]# zip number.zip 1 2 3
    - 예시
    - adding: 1 (stored 0%)
    - adding: 2 (stored 0%)

- # zip 압축 풀기
- [root@localhost ~]# unzip number.zip


- **핵심 개념 3:** 

---

## 💻 2. 실습 및 구현 내용
### ✅ 실습 목표
- 

### 🛠️ 구현 결과
```language
// 코드를 입력하세요
```

### ✨ 새롭게 알게 된 점
- 

---

## 🛠️ 3. 트러블슈팅 (Troubleshooting)
### 🔍 문제 발생 (Issue)
- **상황:** 
- **에러 메시지:** 
- `bash yum install tar -y`

### 💡 원인 분석 (Cause)
- 1. "분명 명령어를 맞게 쳤는데 왜 안 되지?"
- 상황: tar 명령어로 파일을 묶으려고 했는데 터미널이 차갑게 반응했다.


### 🚀 해결 방법 (Solution)
- 에러 메시지: -bash: tar: 명령어를 찾을 수 없음 (command not found)
-  실습을 하는 Rocky Linux 최소 설치(Minimal) 버전이다. 
- 필요한 것만 들어있어서 tar도 직접 깔아줘야 한다


---

## 🧐 4. 오늘의 회고
### 💡 성찰 및 성장
- **습득 지식:** 
- **협업/소통:** 

### 🚀 Action Plan
- **부족한 점:** 
- **개선 방안:** 
- **내일의 목표:** 

---

## 📊 5. 메타인지 측정
### 🎯 오늘의 학습 점수
- **자기 객관화 점수:** ⭐ 0/10
- **이유:** 

---

### 🤝 공유 및 토론
- **참고 자료:** 
- **궁금한 점:** 