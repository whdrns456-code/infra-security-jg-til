# 📅 TIL: 2026-02-16

## 📝 1. 오늘의 학습 주제 및 핵심 내용
- 주요 주제: 수동 세션 관리 방식에서 Spring Security로의 보안 프레임워크 전환

- 핵심 개념 2: RBAC (Role Based Access Control) - 사용자 권한별 URL 접근 제어

- 핵심 개념 3: Concurrency Session Control - 중복 로그인 원천 차단
    - 중복 로그인 제한 (Concurrency Control):
    - 내용: 동일 아이디로 다른 곳에서 로그인하면 기존 세션을 끊어버립니다.
    - 효과: 계정 공유 방지 및 타인의 부정 로그인 시 즉각적인 대응
    - `.maximumSessions(1)`              // 한 아이디당 접속 하나만 허용
    - `.maxSessionsPreventsLogin(false)` 
    - // true 시 세션이 유지되는 동안 로그인 시도시 접근 차단
    - false : 로그인 시도 시 기존 세션은 사라짐

---

## 💻 2. 실습 및 구현 내용
### ✅ 실습 목표
- 기존의 불안정한 HttpSession 직접 조작 방식을 탈피하고, 검증된 스프링 시큐리티 필터 체인을 적용하여 보안 강화

### 🛠️ 구현 결과
```language
// 코드를 입력하세요
```

### ✨ 새롭게 알게 된 점
- 보안의 계층화 (Filter Chain): 기존에는 요청이 컨트롤러까지 들어온 뒤에야 로그인을 체크했지만, 시큐리티는 **'입구(필터)'**에서부터 부적절한 요청을 차단함.
- 인증 정보의 표준화: SecurityContextHolder를 통해 멀티 스레드 환경에서도 안전하게 사용자 인증 정보를 관리함.

---

## 🛠️ 3. 트러블슈팅 (Troubleshooting)
### 🔍 문제 발생 (Issue)
- **상황:** 
    - 상황: 로그인 성공 후에도 헤더 메뉴가 바뀌지 않고, 중복 로그인이 차단되지 않음.
- **에러 메시지:** `Error`

### 💡 원인 분석 (Cause)
- 세션 식별 불가: 시큐리티가 관리하는 인증 정보와 타임리프의 세션 조건문(${session.loginUser})이 서로 일치하지 않음.

### 🚀 해결 방법 (Solution)
- 타임리프 조건문을 시큐리티 전용 문법(sec:authorize 또는 #authentication)으로 교체.
- UserDetailService에서 User.withUsername()을 사용하여 객체 식별성 보장.
---

- 🧐 4. 오늘의 회고
- 💡 성찰 및 성장 (기존 방식과의 차별점)
    - 기존 방식: 내가 직접 성벽을 쌓고 일일이 보초를 서는 수동 보안 방식. 로직이 샐 확률이 높고 관리가 어려움.

    - 시큐리티 방식: 검증된 전문 보안 시스템을 도입한 방식. 중복 로그인 차단, 비밀번호 암호화, 권한 제어가 설정 파일 하나로 통합 관리되어 **'실수할 확률'**을 획기적으로 낮춤.

- 🚀 Action Plan
    - 부족한 점: CSRF 보호 기능에 대한 이해도.
    - 개선 방안: 현재 개발 편의를 위해 disable한 CSRF 설정을 실제 배포 시에는 enable하고, 타임리프 폼에 토큰을 심는 과정을 학습할 예정.
---

## 📊 5. 메타인지 측정
### 🎯 오늘의 학습 점수
- **자기 객관화 점수:** ⭐ 0/10
- **이유:** 

---

### 🤝 공유 및 토론
- **참고 자료:** 
- **궁금한 점:** 